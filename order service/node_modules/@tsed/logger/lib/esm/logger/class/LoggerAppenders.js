import { AppendersRegistry } from "../../appenders/registries/AppendersRegistry.js";
export class LoggerAppenders {
    constructor() {
        this._appenders = new Map();
        this._lvls = new Map();
    }
    get size() {
        return this._appenders.size;
    }
    /**
     * The `has() method returns a boolean indicating whether an element with the specified configuration name exists or not.
     * @param name Required. The key of the element to test for presence in the Map object.`
     * @returns {boolean}
     */
    has(name) {
        return this._appenders.has(name);
    }
    /**
     * The `get() method returns a specified element from a loggerAppenders.
     * @param name Required. The configuration of the element to return from the Map object.
     * @returns {LoggerAppender}
     */
    get(name) {
        return this._appenders.get(name);
    }
    /**
     * The `set()` method adds or updates an element with a specified key and value to a loggerAppenders object.
     * @param name Required. The key of the element to add to the loggerAppenders object.
     * @param config Required. The config of the element to add to the loggerAppenders object.
     * @returns {LoggerAppender}
     */
    set(name, config) {
        const type = typeof config.type === "string" ? config.type : config.type?.$name;
        const opts = {
            level: ["debug", "info", "trace", "error", "warn", "fatal"],
            ...config,
            type,
            options: config.options || {}
        };
        if (!AppendersRegistry.has(opts.type)) {
            console.warn(`Appender ${opts.type} doesn't exists. Check your configuration.`);
            if (["stderr", "stdout"].includes(opts.type)) {
                console.warn("Have you imported the @tsed/logger-std package?");
            }
            opts.type = "console"; // Fallback to console appender
        }
        const klass = AppendersRegistry.get(opts.type).provide;
        const instance = new klass(opts);
        if ("build" in instance) {
            instance.build();
        }
        this._appenders.set(name, { name, instance, config: opts });
        this._lvls.clear();
        return this;
    }
    /**
     * Remove all configuration that match with the `name`.
     * @param name Required. The key of the element to remove from the loggerAppenders object.
     * @returns {boolean} Returns true if an element in the Map object existed and has been removed, or false if the element does not exist.
     */
    delete(name) {
        let existed = this._appenders.delete(name);
        if (existed) {
            this._lvls.clear();
        }
        return existed;
    }
    /**
     * The `clear() method removes all elements from a loggerAppenders object.
     */
    clear() {
        this._appenders.clear();
        this._lvls.clear();
    }
    /**
     * The `forEach()` method executes a provided function once per each key/value pair in the loggerAppenders object, in insertion order.
     * @param callback Function to execute for each element.
     * @param thisArg Value to use as this when executing callback.
     */
    forEach(callback, thisArg) {
        this._appenders.forEach(callback, thisArg);
    }
    /**
     *
     * @returns {Array}
     */
    toArray() {
        const array = [];
        this._appenders.forEach((o) => array.push(o));
        return array;
    }
    /**
     * Return all appenders that match with the given loggingLevel.
     * @param loggingLevel
     * @returns {[BaseAppender]}
     */
    byLogLevel(loggingLevel) {
        const level = loggingLevel.toString();
        if (this._lvls.has(level)) {
            return this._lvls.get(level);
        }
        const list = this.toArray()
            .filter((appender) => appender.config.levels ? appender.config.levels.find((level) => level.toUpperCase() === loggingLevel.toString()) : true)
            .map((appender) => appender.instance);
        this._lvls.set(loggingLevel.toString(), list);
        return list;
    }
}
