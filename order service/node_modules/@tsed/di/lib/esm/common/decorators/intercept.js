import { DecoratorTypes } from "@tsed/core/types/DecoratorTypes.js";
import { Store } from "@tsed/core/types/Store.js";
import { classOf } from "@tsed/core/utils/classOf.js";
import { decorateMethodsOf } from "@tsed/core/utils/decorateMethodsOf.js";
import { decoratorTypeOf } from "@tsed/core/utils/decoratorTypeOf.js";
import { DI_INTERCEPTOR_OPTIONS, DI_INVOKE_OPTIONS } from "../constants/constants.js";
import { inject } from "../fn/inject.js";
export function getInterceptorOptions(target, propertyKey) {
    return Store.fromMethod(target, propertyKey).get(DI_INTERCEPTOR_OPTIONS);
}
export function bindIntercept(target, propertyKey, token, options) {
    const klass = classOf(target);
    const descriptor = Reflect.getOwnPropertyDescriptor(klass.prototype, propertyKey);
    const originalMethod = descriptor.value;
    const symbol = Symbol();
    Store.fromMethod(klass, propertyKey).set(DI_INTERCEPTOR_OPTIONS, options);
    function newMethod(...args) {
        const next = (err) => {
            if (!err) {
                return originalMethod.apply(this, args);
            }
            throw err;
        };
        const context = {
            target: klass,
            propertyKey,
            args,
            options,
            next
        };
        const invokeOpts = {
            rebuild: !!this[DI_INVOKE_OPTIONS]?.rebuild,
            locals: this[DI_INVOKE_OPTIONS]?.locals
        };
        this[symbol] = this[symbol] || inject(token, invokeOpts);
        return this[symbol].intercept({
            ...context,
            options
        }, next);
    }
    descriptor.value = newMethod;
    Reflect.deleteProperty(klass.prototype, propertyKey);
    Reflect.defineProperty(klass.prototype, propertyKey, descriptor);
    return descriptor;
}
/**
 * Attaches interceptor to method call and executes the before and after methods
 *
 * @param interceptor
 * @param options
 * @decorator
 */
export function Intercept(interceptor, options) {
    return (...args) => {
        const [target, propertyKey] = args;
        const type = decoratorTypeOf(args);
        switch (type) {
            case DecoratorTypes.CLASS:
                decorateMethodsOf(target, Intercept(interceptor, options));
                break;
            case DecoratorTypes.METHOD:
                return bindIntercept(target, propertyKey, interceptor, options);
        }
    };
}
