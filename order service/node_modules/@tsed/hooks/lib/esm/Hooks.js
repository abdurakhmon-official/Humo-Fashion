function match(ref, item) {
    return !ref || !item.ref || (ref && item.ref === ref);
}
export class Hooks {
    #listeners = new Map();
    /**
     * Check if an event has listeners
     * @param event
     */
    has(event) {
        return !!this.#listeners.get(event)?.length;
    }
    on(event, cbORef, cb) {
        let ref = cbORef;
        if (!cb) {
            cb = ref;
            ref = undefined;
        }
        const items = this.#listeners.get(event) || [];
        items.push({
            cb,
            ref
        });
        this.#listeners.set(event, items);
        return this;
    }
    once(event, ref, cb) {
        if (!cb) {
            cb = ref;
        }
        const onceCb = (...args) => {
            cb(...args);
            this.off(event, onceCb);
        };
        this.on(event, ref, onceCb);
        return this;
    }
    off(event, cb) {
        const set = (event, items) => {
            if (items.length) {
                this.#listeners.set(event, items);
            }
            else {
                this.#listeners.delete(event);
            }
        };
        if (typeof event === "string" && cb) {
            let items = this.#listeners.get(event);
            if (items) {
                set(event, items.filter((item) => item.cb !== cb));
            }
        }
        else {
            const ref = event;
            this.#listeners.forEach((items, event) => {
                set(event, items.filter((item) => item.ref !== ref));
            });
        }
        return this;
    }
    emit(event, ref, args) {
        if (Array.isArray(ref)) {
            args = ref;
            ref = undefined;
        }
        args ||= [];
        const items = this.#listeners.get(event);
        if (items?.length) {
            for (const item of items) {
                if (match(ref, item)) {
                    item.cb.apply(null, args);
                }
            }
        }
    }
    async asyncEmit(event, ref, args) {
        if (Array.isArray(ref)) {
            args = ref;
            ref = undefined;
        }
        const items = this.#listeners.get(event);
        if (items?.length) {
            const promises = items.filter((item) => match(ref, item)).map((item) => item.cb.apply(null, args));
            await Promise.all(promises);
        }
    }
    /**
     * Trigger an event, listener alter given value and return it.
     * @param event
     * @param value
     * @param args
     * @param callThis
     */
    alter(event, value, args = [], callThis = null) {
        const items = this.#listeners.get(event);
        if (items?.length) {
            for (const { cb } of items) {
                value = cb.call(callThis, value, ...args);
            }
        }
        return value;
    }
    /**
     * Trigger an event, async listener alter given value and return it.
     * @param event
     * @param value
     * @param args
     * @param callThis
     */
    async asyncAlter(event, value, args = [], callThis = null) {
        const items = this.#listeners.get(event);
        if (items?.length) {
            for (const item of items) {
                value = await item.cb.call(callThis, value, ...args);
            }
        }
        return value;
    }
    destroy() {
        this.#listeners.clear();
    }
}
export const hooks = new Hooks();
export const $on = hooks.on.bind(hooks);
export const $once = hooks.once.bind(hooks);
export const $off = hooks.off.bind(hooks);
export const $emit = hooks.emit.bind(hooks);
export const $asyncEmit = hooks.asyncEmit.bind(hooks);
export const $alter = hooks.alter.bind(hooks);
export const $asyncAlter = hooks.asyncAlter.bind(hooks);
