import { injectable, injector, ProviderScope } from "@tsed/di";
import { JsonMethodStore, JsonParameterStore } from "@tsed/schema";
import { ParamValidationError } from "../errors/ParamValidationError.js";
import { ParseExpressionPipe } from "../pipes/ParseExpressionPipe.js";
/**
 * Platform Params abstraction layer.
 * @platform
 */
export class PlatformParams {
    getPipes(param) {
        const get = (pipe) => {
            return injector().getProvider(pipe).priority || 0;
        };
        const sort = (p1, p2) => (get(p1) < get(p2) ? -1 : get(p1) > get(p2) ? 1 : 0);
        const map = (token) => injector().get(token);
        return [ParseExpressionPipe, ...param.pipes.sort(sort)].map(map).filter(Boolean);
    }
    /**
     * Return a handler with injectable parameters
     * @param handlerMetadata
     */
    compileHandler({ propertyKey, token, handler }) {
        if (!token || !propertyKey) {
            return (scope) => handler(scope.$ctx);
        }
        const inj = injector();
        const store = JsonMethodStore.fromMethod(token, propertyKey);
        const getArguments = this.compile(store);
        const provider = inj.getProvider(token);
        return async (scope) => {
            const container = provider.scope === ProviderScope.REQUEST ? scope.$ctx.container : undefined;
            const [instance, args] = await Promise.all([inj.invoke(token, { locals: container }), getArguments(scope)]);
            return instance[propertyKey].call(instance, ...args, scope.$ctx);
        };
    }
    compile(entity) {
        const params = JsonParameterStore.getParams(entity.target, entity.propertyKey);
        const argsPipes = params.map((param) => {
            return {
                param,
                pipes: this.getPipes(param)
            };
        });
        return (scope) => {
            const promises = argsPipes.map(({ param, pipes }) => this.getArg(scope, pipes, param));
            return Promise.all(promises);
        };
    }
    async getArg(scope, pipes, param) {
        try {
            let value = scope;
            for await (const pipe of pipes) {
                value = await pipe.transform(value, param);
            }
            return value;
        }
        catch (er) {
            throw ParamValidationError.from(param, er);
        }
    }
}
injectable(PlatformParams).imports([ParseExpressionPipe]);
