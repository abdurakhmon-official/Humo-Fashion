import { DecoratorTypes } from "@tsed/core/types/DecoratorTypes.js";
import { Metadata } from "@tsed/core/types/Metadata.js";
import { Store } from "@tsed/core/types/Store.js";
import { catchError } from "@tsed/core/utils/catchError.js";
import { decoratorTypeOf } from "@tsed/core/utils/decoratorTypeOf.js";
import { isPromise } from "@tsed/core/utils/isPromise.js";
import { DI_INJECTABLE_PROPS, DI_INVOKE_OPTIONS, DI_USE_OPTIONS } from "../constants/constants.js";
import { InvalidPropertyTokenError } from "../errors/InvalidPropertyTokenError.js";
import { inject } from "../fn/inject.js";
import { injectMany } from "../fn/injectMany.js";
import { getConstructorDependencies, setConstructorDependencies } from "../utils/getConstructorDependencies.js";
function setToken(token, { target, propertyKey, parameterIndex }) {
    const paramTypes = getConstructorDependencies(target, propertyKey);
    const type = paramTypes[parameterIndex];
    paramTypes[parameterIndex] = type === Array ? [token] : token;
    Metadata.setParamTypes(target, propertyKey, paramTypes);
    setConstructorDependencies(target, paramTypes);
}
function getTokenType(token, target, propertyKey) {
    const useType = token || Metadata.getType(target, propertyKey);
    if (useType === Object) {
        throw new InvalidPropertyTokenError(target, String(propertyKey));
    }
    return useType;
}
function bindInjectableProperty(target, propertyKey, { token, transform = (o) => o, useOpts }) {
    const symbol = Symbol();
    if (!target[DI_INJECTABLE_PROPS]) {
        Reflect.defineProperty(target, DI_INJECTABLE_PROPS, {
            value: new Set(),
            enumerable: false,
            configurable: false
        });
    }
    target[DI_INJECTABLE_PROPS].add(propertyKey);
    catchError(() => Reflect.deleteProperty(target, propertyKey));
    Reflect.defineProperty(target, propertyKey, {
        get() {
            const useType = getTokenType(token, target, propertyKey);
            const originalType = Metadata.getType(target, propertyKey);
            const invokeOpts = {
                rebuild: !!this[DI_INVOKE_OPTIONS]?.rebuild,
                locals: this[DI_INVOKE_OPTIONS]?.locals,
                useOpts: useOpts || Store.from(target, propertyKey).get(DI_USE_OPTIONS)
            };
            if (this[symbol] === undefined) {
                this[symbol] = originalType === Array ? injectMany(token, invokeOpts) : inject(useType, invokeOpts);
            }
            [].concat(this[symbol]).forEach((instance, index) => {
                if (isPromise(this[symbol])) {
                    instance.then((result) => {
                        this[symbol][index] = result;
                        if (originalType !== Array) {
                            this[symbol] = result;
                        }
                    });
                }
            });
            return transform(this[symbol], { self: this, target, propertyKey });
        }
    });
}
export function Inject(token, opts = {}) {
    opts = typeof opts === "function" ? { transform: opts } : opts;
    return (target, propertyKey, index) => {
        const bindingType = decoratorTypeOf([target, propertyKey, index]);
        switch (bindingType) {
            case DecoratorTypes.PARAM_CTOR:
                if (token) {
                    setToken(token, { target, propertyKey, parameterIndex: index });
                }
                break;
            case DecoratorTypes.PROP:
                bindInjectableProperty(target, propertyKey, { ...opts, token });
        }
    };
}
