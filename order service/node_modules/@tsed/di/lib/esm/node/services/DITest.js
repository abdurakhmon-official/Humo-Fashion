import { Env } from "@tsed/core/types/Env.js";
import { getValue } from "@tsed/core/utils/getValue.js";
import { isClass } from "@tsed/core/utils/isClass.js";
import { isObject } from "@tsed/core/utils/isObject.js";
import { $log } from "@tsed/logger";
import { DIContext } from "../../common/domain/DIContext.js";
import { cleanAllLocalsContainer, detachLocalsContainer, localsContainer } from "../../common/fn/localsContainer.js";
import { logger } from "../../common/fn/logger.js";
import { createContainer, destroyInjector, DI_INJECTABLE_PROPS, inject, injector } from "../../common/index.js";
import { setLoggerConfiguration } from "../../common/utils/setLoggerConfiguration.js";
/**
 * Tool to run test with lightweight DI sandbox.
 */
export class DITest {
    static get injector() {
        return injector();
    }
    static async create(settings = {}) {
        DITest.createInjector(settings);
        await DITest.createContainer();
    }
    static async createContainer() {
        await injector().load(createContainer());
    }
    /**
     * Create a new injector with the right default services
     */
    static createInjector(settings = {}) {
        const inj = injector();
        injector().logger = $log;
        inj.settings.set(DITest.configure(settings));
        setLoggerConfiguration();
        return inj;
    }
    /**
     * Resets the test injector of the test context, so it won't pollute your next test. Call this in your `tearDown` logic.
     */
    static async reset() {
        await destroyInjector();
        cleanAllLocalsContainer();
    }
    /**
     * Invoke a provider and return a fresh instance
     * @param target
     * @param providers
     */
    static async invoke(target, providers = []) {
        const locals = localsContainer({ providers, rebuild: true });
        const instance = inject(target, { locals, rebuild: true });
        if (instance && isObject(instance) && instance?.$onInit) {
            const result = instance.$onInit();
            if (result instanceof Promise) {
                return result
                    .then(() => {
                    return;
                })
                    .then(() => instance);
            }
        }
        if (isClass(instance)) {
            const keys = instance[DI_INJECTABLE_PROPS];
            if (keys) {
                await Promise.all([...keys.keys()].map((key) => instance[key]));
            }
        }
        detachLocalsContainer();
        return instance;
    }
    /**
     * Return the instance from injector registry
     * @param target
     */
    static get(target) {
        return injector().get(target);
    }
    static createDIContext() {
        return new DIContext({
            id: "id",
            injector: injector(),
            logger: logger()
        });
    }
    static configure(settings = {}) {
        return {
            ...settings,
            env: getValue(settings, "env", Env.TEST),
            logger: {
                ...getValue(settings, "logger", {}),
                level: getValue(settings, "logger.level", "off")
            }
        };
    }
}
