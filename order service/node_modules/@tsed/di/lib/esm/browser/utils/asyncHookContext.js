class AsyncContextStorage {
    constructor() {
        this.stack = [];
    }
    run(store, cb) {
        this.stack.push(store);
        this.store = store;
        try {
            return cb();
        }
        finally {
            this.stack.pop();
            this.store = this.stack[this.stack.length - 1];
        }
    }
    getStore() {
        return this.store;
    }
}
const storage = new AsyncContextStorage();
export function getAsyncStore() {
    return storage;
}
export function useContextRef() {
    return getAsyncStore().getStore();
}
export function getContext(initialValue) {
    return initialValue || useContextRef()?.current;
}
export async function runInContext(ctx, cb, injector) {
    const ref = useContextRef();
    if (ref) {
        ctx && setContext(ctx);
        return cb();
    }
    else {
        injector = ctx?.injector || injector;
        cb = (injector && (await injector.alterAsync?.("$alterRunInContext", cb))) || cb;
        return await Promise.resolve(storage.run({ current: ctx }, cb));
    }
}
export function setContext(ctx) {
    const ref = useContextRef();
    if (ref && !ref.current) {
        ref.current = ctx;
    }
}
/**
 * @deprecated
 */
export function bindContext(cb) {
    return cb;
}
if (typeof window !== "undefined") {
    // Patch Promise.then pour propager le contexte
    const origThen = Promise.prototype.then;
    Promise.prototype.then = function (onFulfilled, onRejected) {
        const ctx = useContextRef();
        return origThen.call(this, onFulfilled && ((v) => storage.run({ current: ctx?.current }, () => onFulfilled(v))), onRejected && ((e) => storage.run({ current: ctx?.current }, () => onRejected(e))));
    };
    // Patch setTimeout pour propager le contexte
    const origSetTimeout = window.setTimeout;
    window.setTimeout = function (fn, ...args) {
        const ctx = useContextRef();
        return origSetTimeout(() => storage.run({ current: ctx?.current }, fn), ...args);
    };
}
