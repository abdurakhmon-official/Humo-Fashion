import { getValue } from "@tsed/core";
import { constant, inject, injectable, injector, ProviderType } from "@tsed/di";
import { $on, Hooks } from "@tsed/hooks";
import { concatPath, getOperationsRoutes, OPERATION_HTTP_VERBS } from "@tsed/schema";
import { useContextHandler } from "../utils/useContextHandler.js";
import { PlatformLayer } from "./PlatformLayer.js";
import { PlatformRouter } from "./PlatformRouter.js";
let AUTO_INC = 0;
function getInjectableRouter(provider) {
    return injector().get(provider.tokenRouter);
}
function createTokenRouter(provider) {
    return (provider.tokenRouter = provider.tokenRouter || `${provider.name}_ROUTER_${AUTO_INC++}`);
}
function createInjectableRouter(provider) {
    const tokenRouter = createTokenRouter(provider);
    if (injector().has(tokenRouter)) {
        return getInjectableRouter(provider);
    }
    const router = inject(PlatformRouter);
    router.provider = provider;
    return injector()
        .add(tokenRouter, {
        useValue: router
    })
        .invoke(tokenRouter);
}
export class PlatformRouters {
    constructor() {
        this.hooks = new Hooks();
        this.allowedVerbs = OPERATION_HTTP_VERBS;
    }
    prebuild() {
        injector()
            .getProviders(ProviderType.CONTROLLER)
            .forEach((provider) => {
            createInjectableRouter(provider);
        });
    }
    from(token, parentMiddlewares = []) {
        const provider = injector().getProvider(token);
        if (!provider) {
            throw new Error("Token not found in the provider registry");
        }
        const router = createInjectableRouter(provider);
        if (router.isBuilt()) {
            return router;
        }
        const useBefore = getValue(provider, "middlewares.useBefore", []);
        const middlewares = [...parentMiddlewares, ...useBefore];
        const { children } = provider;
        // Set default to true in next major version
        const appendChildrenRoutesFirst = constant("router.appendChildrenRoutesFirst", false);
        if (appendChildrenRoutesFirst) {
            children.forEach((token) => {
                const nested = this.from(token, middlewares);
                router.use(nested);
            });
        }
        getOperationsRoutes(provider.token, { allowedVerbs: this.allowedVerbs }).forEach((operationRoute) => {
            const { endpoint } = operationRoute;
            const { beforeMiddlewares, middlewares: mldwrs, afterMiddlewares } = endpoint;
            const useBefore = getValue(provider, "middlewares.useBefore", []);
            const use = getValue(provider, "middlewares.use", []);
            const useAfter = getValue(provider, "middlewares.useAfter", []);
            let handlers = this.hooks.alter("alterEndpointHandlers", {
                before: [...parentMiddlewares, ...useBefore, ...beforeMiddlewares, ...use, ...mldwrs],
                endpoint,
                after: [...afterMiddlewares, ...useAfter]
            }, [operationRoute], this);
            handlers = this.sortHandlers(handlers);
            router.addRoute(operationRoute.method, operationRoute.path || "", [
                useContextHandler(($ctx) => {
                    $ctx.endpoint = operationRoute.endpoint;
                }),
                ...[...handlers.before, handlers.endpoint, ...handlers.after]
            ], operationRoute);
        });
        if (!appendChildrenRoutesFirst) {
            children.forEach((token) => {
                const nested = this.from(token, middlewares);
                router.use(nested);
            });
        }
        return router;
    }
    getLayers(router) {
        return this.flatMapLayers(router.layers);
    }
    sortHandlers(handlers) {
        const get = (token) => {
            return injector().getProvider(token)?.priority || 0;
        };
        const sort = (p1, p2) => (get(p1) < get(p2) ? -1 : get(p1) > get(p2) ? 1 : 0);
        handlers.before = handlers.before.sort(sort);
        handlers.after = handlers.after.sort(sort);
        return handlers;
    }
    flatMapLayers(layers) {
        return layers
            .flatMap((layer) => {
            if (layer.router) {
                return this.flatMapLayers(layer.layers).map((subLayer) => {
                    return new PlatformLayer({
                        ...subLayer,
                        path: concatPath(layer.path, subLayer.path)
                    });
                });
            }
            return new PlatformLayer(layer);
        })
            .map((layer) => {
            const handlers = layer.handlers.map((handlerMetadata) => {
                // set path on handler metadata to retrieve it later in $ctx
                handlerMetadata.path = layer.path;
                if (handlerMetadata.isRawFn()) {
                    return handlerMetadata.handler;
                }
                return this.hooks.alter("alterHandler", handlerMetadata);
            });
            layer.set(handlers);
            return layer;
        });
    }
}
injectable(PlatformRouters);
/**
 * Create injectable router for the current invoked provider.
 * @ignore
 */
$on(`$beforeInvoke:${ProviderType.CONTROLLER}`, ({ provider, locals }) => {
    const router = createInjectableRouter(provider);
    locals.set(PlatformRouter, router);
});
