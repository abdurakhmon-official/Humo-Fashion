import { getClassOrSymbol } from "@tsed/core/utils/getClassOrSymbol.js";
import { Provider } from "../domain/Provider.js";
import { ProviderType } from "../domain/ProviderType.js";
export class GlobalProviderRegistry extends Map {
    #settings = new Map();
    /**
     * The get() method returns a specified element from a Map object.
     * @param key Required. The key of the element to return from the Map object.
     * @returns {T} Returns the element associated with the specified key or undefined if the key can't be found in the Map object.
     */
    get(key) {
        return super.get(getClassOrSymbol(key));
    }
    /**
     * The has() method returns a boolean indicating whether an element with the specified key exists or not.
     * @param key
     * @returns {boolean}
     */
    has(key) {
        return super.has(getClassOrSymbol(key));
    }
    /**
     * The set() method adds or updates an element with a specified key and value to a Map object.
     * @param key Required. The key of the element to add to the Map object.
     * @param metadata Required. The value of the element to add to the Map object.
     */
    set(key, metadata) {
        super.set(getClassOrSymbol(key), metadata);
        return this;
    }
    /**
     *
     * @param target
     * @param options
     */
    merge(target, options) {
        if (options.global === false) {
            return GlobalProviders.createProvider(target, options);
        }
        const meta = this.createIfNotExists(target, options);
        Object.keys(options).forEach((key) => {
            meta[key] = options[key];
        });
        this.set(target, meta);
        return meta;
    }
    /**
     * The delete() method removes the specified element from a Map object.
     * @param key Required. The key of the element to remove from the Map object.
     * @returns {boolean} Returns true if an element in the Map object existed and has been removed, or false if the element does not exist.
     */
    delete(key) {
        return super.delete(getClassOrSymbol(key));
    }
    createRegistry(type, model, options = {}) {
        const defaultOptions = this.getRegistrySettings(type);
        options = Object.assign(defaultOptions, {
            ...options,
            model
        });
        this.#settings.set(type, options);
        return this;
    }
    getRegistrySettings(target) {
        let type = ProviderType.PROVIDER;
        if (typeof target === "string") {
            type = target;
        }
        else {
            const provider = this.get(target);
            if (provider) {
                type = provider.type;
            }
        }
        return (this.#settings.get(type) || {
            model: Provider
        });
    }
    createProvider(key, options) {
        const type = options.type || ProviderType.PROVIDER;
        const { model = Provider } = this.#settings.get(type) || {};
        return new model(key, options);
    }
    /**
     *
     * @param key
     * @param options
     */
    createIfNotExists(key, options) {
        if (!this.has(key)) {
            const item = this.createProvider(key, options);
            this.set(key, item);
        }
        return this.get(key);
    }
}
/**
 *
 * @type {GlobalProviders}
 */
// tslint:disable-next-line: variable-name
export const GlobalProviders = new GlobalProviderRegistry();
