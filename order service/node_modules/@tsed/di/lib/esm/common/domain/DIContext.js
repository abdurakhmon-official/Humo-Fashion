import { injector, LocalsContainer } from "../index.js";
import { ContextLogger } from "./ContextLogger.js";
export class DIContext {
    #container;
    #cache;
    #logger;
    constructor(opts) {
        this.opts = opts;
        this.PLATFORM = "DI";
        this.PLATFORM = opts.platform || this.PLATFORM;
    }
    /**
     * Logger attached to the context request.
     */
    get logger() {
        this.#logger = this.#logger || new ContextLogger(this.opts);
        return this.#logger;
    }
    /**
     * Request id generated by @@contextMiddleware@@.
     *
     * ::: tip
     * By default Ts.ED generate uuid like that `uuidv4().replace(/-/gi, ""))`.
     * Dash are removed to simplify tracking logs in Kibana
     * :::
     *
     * ::: tip
     * Request id can by customized by changing the server configuration.
     *
     * ```typescript
     * @Configuration({
     *   logger: {
     *     reqIdBuilder: createUniqId // give your own id generator function
     *   }
     * })
     * class Server {
     *
     * }
     * ```
     * :::
     *
     */
    get id() {
        return this.opts.id;
    }
    get dateStart() {
        return this.logger.dateStart;
    }
    get injector() {
        return injector();
    }
    get env() {
        return this.injector.settings.get("env");
    }
    /**
     * The request container used by the Ts.ED DI. It contains all services annotated with `@Scope(ProviderScope.REQUEST)`
     */
    get container() {
        return (this.#container = this.#container || new LocalsContainer());
    }
    destroy() {
        return Promise.all([this.#container?.destroy(), this.#logger?.flush(true)]);
    }
    cache(key, cb) {
        if (!this.has(key)) {
            this.set(key, cb());
        }
        return this.get(key);
    }
    async cacheAsync(key, cb) {
        if (!this.has(key)) {
            this.set(key, await cb());
        }
        return this.get(key);
    }
    delete(key) {
        return !!this.#cache?.delete(key);
    }
    get(key) {
        return this.#cache?.get(key);
    }
    has(key) {
        return !!this.#cache?.has(key);
    }
    set(key, value) {
        this.#cache = this.#cache || new Map();
        this.#cache.set(key, value);
        return this;
    }
}
